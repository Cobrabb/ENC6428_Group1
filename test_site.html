<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
        <script src="crossword.js"></script>
        <script src="blake001.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #table
        {
            width:100%;
            height:100%; 
            background-color:Black;  
        }
        #renderCanvas 
        {
            width:100%;
            top:0px;
            height:100%;
            touch-action: none;
        }
        #parent{
            position:fixed;
            width:20%;
            height:60%;
            bottom:0px;
            right:0px;
            background-color: black;
            color:white;
        }
        #txtPoem{
            padding:10%;
        }
    </style>


    <body>
    <canvas id ="renderCanvas"></canvas>
    <div id="parent">
    <div id="txtPoem"></div>
    </div>

 <!--   <table id="table" >
        <tr>
            <td style="width:85%" >
            </td>
            <td style="background-color:Black; margin-top:auto; width:15%">
                    <textarea id="txtPoem" style="background-color:Black; position:absolute; top:0px; height: 40%; overflow-y:scroll; color:White" disabled="disabled">
                    </textarea>
                    <div id = "camera2">

                    </div>
            </td>
        </tr>
            
        
    </table> -->

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);

    BABYLON.Mesh.CreatePyramid4 = function (name, baseSize, height, scene, updatable) {  
        var pyramid = new BABYLON.Mesh(name, scene);
        
        // Adding faces
        var positions = [
        // Front face
        0,  height/2,  0,
        baseSize/2, -height/2, baseSize/2,
        -baseSize/2, -height/2, baseSize/2,

        // Right face
        0, height/2, 0,
        baseSize/2, -height/2, -baseSize/2,
        baseSize/2, -height/2, baseSize/2,

        // Back face
        0, height/2,  0,
        -baseSize/2, -height/2, -baseSize/2,
        baseSize/2, -height/2, -baseSize/2,

        // Left face
        0, height/2,  0,
        -baseSize/2, -height/2, baseSize/2,
        -baseSize/2, -height/2, -baseSize/2,

        // Bottom face
        -baseSize/2, -height/2, baseSize/2,
        baseSize/2, -height/2, baseSize/2,
        baseSize/2, -height/2, -baseSize/2,
        -baseSize/2, -height/2, -baseSize/2


         ];

         var normals = [
    height, baseSize/2, 0,
    height, baseSize/2, 0,
    height, baseSize/2, 0,

    0, baseSize/2, height,
    0, baseSize/2, height,
    0, baseSize/2, height,

    -height, baseSize/2, 0,
    -height, baseSize/2, 0,
    -height, baseSize/2, 0,

    0, baseSize/2, -height,
    0, baseSize/2, -height,
    0, baseSize/2, -height,

    0, -1, 0,
    0, -1, 0,
    0, -1, 0,
    0, -1, 0
  ];

    var indices = [];
  var uvs = [];
  var i = 0;

    while (i < 12) {
    indices.push(i+0);
    uvs.push(1.0, 1.0);
    indices.push(i+1);
    uvs.push(0.0, 1.0);
    indices.push(i+2);
    uvs.push(0.0, 0.0);
    i = i+3;
  }

    indices.push(12);
  indices.push(13);
  indices.push(14);

  indices.push(12);
  indices.push(14);
  indices.push(15);

  uvs.push(1.0, 1.0);
  uvs.push(0.0, 1.0);
  uvs.push(0.0, 0.0);
  uvs.push(1.0, 0.0);   

  pyramid.setVerticesData(positions, BABYLON.VertexBuffer.PositionKind, updatable);
  pyramid.setVerticesData(normals, BABYLON.VertexBuffer.NormalKind, updatable);
  pyramid.setVerticesData(uvs, BABYLON.VertexBuffer.UVKind, updatable);
  pyramid.setIndices(indices);

  return pyramid;
}
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        //scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
        //scene.fogColor = new BABYLON.Color3(.4, .4, .35);

        // Need a free camera for collisions
        var skybox = BABYLON.Mesh.CreateBox("skyBox", 300.0, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.position = new BABYLON.Vector3(150, 0, 150);
        skybox.material = skyboxMaterial;

        var cameraPos = 0 ;

        var box = new BABYLON.Mesh.CreatePyramid4("box", 3, 4, scene, false);
        box.material = new BABYLON.StandardMaterial("texture1", scene);
        box.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
        box.rotation.x = Math.PI/4;
        box.checkCollisions = false;

        camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(cameraPos, 2, cameraPos), scene);
        camera.viewport = new BABYLON.Viewport(0, 0, .8, 1);
        miniMap = new BABYLON.FreeCamera("FreeCamera2", new BABYLON.Vector3(cameraPos, 20, cameraPos), scene);
        miniMap.viewport = new BABYLON.Viewport(.8, .6, .3, .4);
        miniMap.fov = 2;
        miniMap.cameraRotation.x = (Math.PI/4);

        box.parent = camera;

        //miniMap.setTarget(camera.position);
        //miniMap.parent = camera;

        scene.activeCameras.push(camera);
        scene.activeCameras.push(miniMap);
        // Lights
        //var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var lights = [];

        var dist = 3;
        lights[0] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, 1*dist), scene);
        lights[1] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, 1*dist), scene);
        lights[2] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, -1*dist), scene);
        lights[3] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, -1*dist), scene);

        for(var i=0; i<4; i++){
            lights[i].intensity = .2; 
            lights[i].parent = camera;
        }

        //Use this camera position for checking letters --> Easy navigation
        //var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 40, 0), scene);

        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        vidSetup(scene);
        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 300, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        if(TEXTURES_ON){
            ground.material.bumpTexture = new BABYLON.Texture("ground_bump2.jpg", scene);
            ground.material.bumpTexture.uScale = 10;
            ground.material.bumpTexture.vScale = 10;
        }
        ground.material.diffuseColor = new BABYLON.Color3(.4, .2, 0);
        ground.material.backFaceCulling = false;
        ground.material.specularColor = new BABYLON.Color3(.2, .2, .298);
        ground.position = new BABYLON.Vector3(150, 0, 150);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene, camera);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = true;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        POEM = [];
        

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
        for(var i=0; i<l.letterGrid.length;i++){
            for(var j=0; j<l.letterGrid.length; j++){
                var letter = l.letterGrid[i][j];
                if(letter!=null){
                    if(letter.xBegin <= camera.position.x && letter.xEnd >= camera.position.x && letter.zBegin <= camera.position.z && letter.zEnd >= camera.position.z){
                        if(letter == l.eastExit){
                            console.log("IN the east exit");
                        }else if(letter == l.westExit){
                            console.log("IN the west exit");
                        }else if(letter == l.northExit){
                            console.log("IN the north exit");
                        }else if(letter == l.southExit){
                            console.log("IN the south exit");
                        }
                        addToPoem(letter.objletter.word);
                    }
                }
            }
        }
        miniMap.position.x = camera.position.x;
        miniMap.position.z = camera.position.z;
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function addToPoem(word){
        for(var i=0; i<POEM.length; i++){
            if(POEM[i] == word){
                return;
            }    
        }
        POEM[POEM.length] = word;
        document.getElementById("txtPoem").innerHTML += word + " ";
    }

    function renderMap(scene){
        
        var playerX = camera.position.x;
        var playerZ = camera.position.z;

        var wordList = getHuge();

        var grid = renderCrossword(wordList, "M", 10, 10);
        l = renderLetterGrid(scene, grid, true, true);

        var done = false;
        //Put the player somewhere sane
        for(var i=Math.floor(l.letterGrid.length/2); i<l.letterGrid.length; i++){
            for(var j=Math.floor(l.letterGrid.length/2); j<l.letterGrid.length; j++){
                if(l.letterGrid[i][j]!=null){
                    camera.position.x = l.letterGrid[i][j].xBegin+1.5;
                    camera.position.z = l.letterGrid[i][j].zBegin+1.5;
                    miniMap.position.x = l.letterGrid[i][j].xBegin+1.5;
                    miniMap.position.z = l.letterGrid[i][j].zBegin+1.5;
                    camera.position.y = 15;
                    //alert(l.letterGrid[i][j].xBegin +  " " + l.letterGrid[i][j].zBegin) ;
                    done = true;
                    break;
                }
            }
            if(done) break;
        }

    }

    function getBlake(){
        var rand = Math.random()*(BLAKE001.length-1);
        rand = Math.round(rand);

        return BLAKE001[rand].split(" ");
    }

    function getHuge(){
        var max = 5;
        var cursize = 0;
        var ret = [];
        for(var i=0; i<max; i++){
            var newWord = getBlake();
            for(var j=cursize; j<cursize+newWord.length; j++){
                ret[j] = newWord[j-cursize].toUpperCase();
            }
            cursize += newWord.length;
        }
        return ret;
    }

    //Renders a crossword. xPos and zPos represent the position in the crossword that wordList[0] will have.
    function renderCrossword(wordList, dir, xPos, zPos){
        var cw = new Crossword(wordList, dir, xPos, zPos);

        var grid = cw.getSquareGrid(2);
        return grid;
    }


</script>

</body>
