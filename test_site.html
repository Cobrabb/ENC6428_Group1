<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>


    <body>

        <canvas id ="renderCanvas"></canvas>

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);

        // Lights
        var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, 20, 20), scene);

        // Need a free camera for collisions
        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(1, 1, 1), scene);
        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 100, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        ground.material.backFaceCulling = false;
        ground.position = new BABYLON.Vector3(50, 0, 50);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = false;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function renderMap(scene){
		
		//var G = createG(scene, 0, 0, false, true, false, false);

        var J = createJ(scene, 0, 0, false,true,false,false);
        var O = createO(scene, J.xEnd+3, 0, false,true,false,true);
        var L1 = createL(scene, O.xEnd+3, 0, false,true,false,true);
        var L2 = createL(scene, L1.xEnd+3, 0, false,true,false,true);
        var Y = createY(scene, L2.xEnd+3, 0, false,false,false,true);

        createWall(scene, [J.xBegin, J.zEnd], [Y.xEnd, Y.zEnd]);
        createWall(scene, [J.xBegin, J.zBegin], [Y.xEnd, Y.zBegin]);
		
		//var L = createL(scene, 14, 0, false, true, false, true);
		
		//var L = createL(scene, 21, 0, false, false, false, true);
        //alert(L.xBegin + " " + L.xEnd);
        //L.checkCollision(1, 1);
    }

    function checkCollision(playerX, playerZ){
        if(playerX > this.xBegin && playerX < this.xEnd && playerZ > this.zBegin && playerZ < this.zEnd){
            //alert("TEST");
        }
    }





    function createWall(scene, begin, end){
        var height = 30;
        var scaling = .1;

        var midx = (begin[0]+end[0])/2.0;
        var midz = (begin[1]+end[1])/2.0;

        var box = new BABYLON.Mesh.CreateBox("crate", scaling, scene);
        box.material = new BABYLON.StandardMaterial("Mat", scene);
        box.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
        box.position = new BABYLON.Vector3(midx, (height/2)*scaling, midz);
        box.checkCollisions = true;
        box.scaling.y = height;
        

        var xDist = begin[0]-end[0];
        var zDist = begin[1]-end[1];
        box.scaling.x = (Math.sqrt(xDist*xDist+zDist*zDist))*10;
        box.rotation.y = 0-(Math.atan(zDist/xDist));
    }


</script>

</body>
