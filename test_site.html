<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
        <script src="crossword.js"></script>
        <script src="blake001.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #table
        {
            width:100%;
            height:100%; 
            background-color:Black;  
        }
        #renderCanvas 
        {
            width:100%;
            top:0px;
            height:100%;
            touch-action: none;
        }
    </style>


    <body>
    <table id="table" >
        <tr>
            <td style="width:85%" >
                <canvas id ="renderCanvas"></canvas>
            </td>
            <td style="background-color:Black; margin-top:auto; width:15%">
                    <textarea id="txtPoem" style="background-color:Black; position:absolute; top:0px; height: 40%; overflow-y:scroll; color:White" disabled="disabled">Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here Poem Goes Here </textarea>
            </td>
        </tr>
            
        
    </table>

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        //scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
        //scene.fogColor = new BABYLON.Color3(.4, .4, .35);

        // Need a free camera for collisions
        var skybox = BABYLON.Mesh.CreateBox("skyBox", 10000.0, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.material = skyboxMaterial;

        var cameraPos = 0 ;

        camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(cameraPos, 1, cameraPos), scene);

        // Lights
        //var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var lights = [];

        var dist = 3;
        lights[0] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, 1*dist), scene);
        lights[1] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, 1*dist), scene);
        lights[2] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, -1*dist), scene);
        lights[3] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, -1*dist), scene);

        for(var i=0; i<4; i++){
            lights[i].intensity = .2; 
            lights[i].parent = camera;
        }

        //Use this camera position for checking letters --> Easy navigation
        //var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 40, 0), scene);

        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        vidSetup(scene);
        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 10000, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        if(TEXTURES_ON){
            ground.material.bumpTexture = new BABYLON.Texture("ground_bump2.jpg", scene);
            ground.material.bumpTexture.uScale = 1000;
            ground.material.bumpTexture.vScale = 1000;
        }
        ground.material.diffuseColor = new BABYLON.Color3(.4, .2, 0);
        ground.material.backFaceCulling = false;
        ground.material.specularColor = new BABYLON.Color3(.2, .2, .298);
        ground.position = new BABYLON.Vector3(0, 0, 0);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene, camera);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = false;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;
        
        //var postProcess2 = new BABYLON.BlurPostProcess("Horizontal blur", new BABYLON.Vector2(1.0, 0), 20, 1.5, scene.activeCamera, BABYLON.Texture.DEFAULT_SAMPLINGMODE);

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function renderMap(scene){
        
        var playerX = camera.position.x;
        var playerZ = camera.position.z;

        var wordList = getHuge();

        var grid = renderCrossword(wordList, "M", 10, 10);
        var l = renderLetterGrid(scene, grid, 0, 0, true, true);

        //Put the player somewhere sane
        for(var i=0; i<l.letterGrid.length; i++){
            for(var j=0; j<l.letterGrid.length; j++){
                if(l.letterGrid[i][j]!=null){
                    camera.position.x = l.letterGrid[i][j].xBegin+1.5;
                    camera.position.z = l.letterGrid[i][j].zBegin+1.5;
                    break;
                }
            }
        }

        //delayedRenderer(scene, "E", l);
        //alert(l.letterGrid[l.eastPoint[0]][l.eastPoint[1]].objletter.char + " " + l.letterGrid[l.eastPoint[0]][l.eastPoint[1]].objletter.direction);
        //window.setTimeout("delayedRender()", 5000);

    }

/*    function getTwoBlake(){
        var rand = Math.random()*(BLAKE001.length-1);
        rand = Math.round(rand);
        if(rand%2==1){
            rand = rand-1;
        }

        var wordList = [];
        var split1 = BLAKE001[rand].split(" ");
        var split2 = BLAKE001[rand+1].split(" ");

        for(var i=0; i<split1.length; i++){
            wordList[i] = split1[i].toUpperCase();
        }

        var oldSize = wordList.length;
        for(var i=0; i<split2.length; i++){
            wordList[oldSize+i] = split2[i].toUpperCase();
        }

        return wordList;
    } */

    function getBlake(){
        var rand = Math.random()*(BLAKE001.length-1);
        rand = Math.round(rand);

        return BLAKE001[rand].split(" ");
    }

    function getHuge(){
        var max = 20;
        var cursize = 0;
        var ret = [];
        for(var i=0; i<max; i++){
            var newWord = getBlake();
            for(var j=cursize; j<cursize+newWord.length; j++){
                ret[j] = newWord[j-cursize].toUpperCase();
            }
            cursize += newWord.length;
        }
        return ret;
    }

/*    function delayedRenderer(scene, dir, prev){
        if(dir == "E"){
            var word = getWord(prev.letterGrid, prev.eastPoint[0], prev.eastPoint[1]);
            var newWordList = getTwoBlake();

            var newNewWordList = [];
            newNewWordList[0] = word.split("").reverse().join("");
            for(var i=0; i<newWordList.length; i++){
                newNewWordList[i+1] = newWordList[i];
            }

            var grid = renderCrossword(newNewWordList, "E", prev.eastPoint[0], prev.eastPoint[1]);  
            var l = renderLetterGrid(scene, grid, -100, -100, true, true); 

        }

    }

    function getWord(grid, startx, startz){
        var word = "";
        var dir = grid[startx][startz].objletter.direction;
        if(dir == "down"){
            curind = 0;
            do{
                if(grid[startx-curind] == null){
                    curr = null;
                }else{
                    curr = grid[startx-curind][startz];
                }
                if(curr!=null)
                    word += curr.objletter.char;
                curind--;
            }while(curr!=null);
        }else{
            curind = 0;
            do{
                if(grid[startx][startz-curind] == null){
                    curr = null;
                }else{
                    curr = grid[startx][startz-curind];
                }
                if(curr!=null)
                    word += curr.objletter.char;
                curind--;
            }while(curr!=null);
        }
        return word;
    }
    */

    //Renders a crossword. xPos and zPos represent the position in the crossword that wordList[0] will have.
    function renderCrossword(wordList, dir, xPos, zPos){
        var cw = new Crossword(wordList, dir, xPos, zPos);

        var grid = cw.getSquareGrid(2);
        return grid;
    }


</script>

</body>
