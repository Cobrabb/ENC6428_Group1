<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
        <script src="crossword.js"></script>
        <script src="blake001.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #table
        {
            width:100%;
            height:100%; 
            background-color:Black;  
        }
        #renderCanvas 
        {
            width:100%;
            top:0px;
            height:100%;
            touch-action: none;
        }
    </style>


    <body>
    <table id="table" >
        <tr>
            <td style="width:85%" >
                <canvas id ="renderCanvas"></canvas>
            </td>
            <td style="background-color:Black; margin-top:auto; width:15%">
                    <textarea id="txtPoem" style="background-color:Black; position:absolute; top:0px; height: 40%; overflow-y:scroll; color:White" disabled="disabled">
                    </textarea>
            </td>
        </tr>
            
        
    </table>

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
        scene.fogColor = new BABYLON.Color3(.4, .4, .35);

        // Need a free camera for collisions
        var skybox = BABYLON.Mesh.CreateBox("skyBox", 300.0, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/skybox", scene);
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        skybox.position = new BABYLON.Vector3(150, 0, 150);
        skybox.material = skyboxMaterial;

        var cameraPos = 0 ;

        camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(cameraPos, 1.5, cameraPos), scene);

        // Lights
        //var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var lights = [];

        var dist = 3;
        lights[0] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, 1*dist), scene);
        lights[1] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, 1*dist), scene);
        lights[2] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-1*dist, 1, -1*dist), scene);
        lights[3] = new BABYLON.PointLight("Omni", new BABYLON.Vector3(1*dist, 1, -1*dist), scene);

        for(var i=0; i<4; i++){
            lights[i].intensity = .2; 
            lights[i].parent = camera;
        }

        //Use this camera position for checking letters --> Easy navigation
        //var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 40, 0), scene);

        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        vidSetup(scene);
        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 300, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        if(TEXTURES_ON){
            ground.material.bumpTexture = new BABYLON.Texture("ground_bump2.jpg", scene);
            ground.material.bumpTexture.uScale = 10;
            ground.material.bumpTexture.vScale = 10;
        }
        ground.material.diffuseColor = new BABYLON.Color3(.4, .2, 0);
        ground.material.backFaceCulling = false;
        ground.material.specularColor = new BABYLON.Color3(.2, .2, .298);
        ground.position = new BABYLON.Vector3(150, 0, 150);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene, camera);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = true;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        POEM = [];
        

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
        for(var i=0; i<l.letterGrid.length;i++){
            for(var j=0; j<l.letterGrid.length; j++){
                var letter = l.letterGrid[i][j];
                if(letter!=null){
                    if(letter.xBegin <= camera.position.x && letter.xEnd >= camera.position.x && letter.zBegin <= camera.position.z && letter.zEnd >= camera.position.z){
                        if(letter == l.eastExit){
                            console.log("IN the east exit");
                        }else if(letter == l.westExit){
                            console.log("IN the west exit");
                        }else if(letter == l.northExit){
                            console.log("IN the north exit");
                        }else if(letter == l.southExit){
                            console.log("IN the south exit");
                        }
                        addToPoem(letter.objletter.word);
                    }
                }
            }
        }
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function addToPoem(word){
        for(var i=0; i<POEM.length; i++){
            if(POEM[i] == word){
                return;
            }    
        }
        POEM[POEM.length] = word;
        document.getElementById("txtPoem").innerHTML += word + " ";
    }

    function renderMap(scene){
        
        var playerX = camera.position.x;
        var playerZ = camera.position.z;

        var wordList = getHuge();

        var grid = renderCrossword(wordList, "M", 10, 10);
        l = renderLetterGrid(scene, grid, true, true);

        var done = false;
        //Put the player somewhere sane
        for(var i=Math.floor(l.letterGrid.length/2); i<l.letterGrid.length; i++){
            for(var j=Math.floor(l.letterGrid.length/2); j<l.letterGrid.length; j++){
                if(l.letterGrid[i][j]!=null){
                    camera.position.x = l.letterGrid[i][j].xBegin+1.5;
                    camera.position.z = l.letterGrid[i][j].zBegin+1.5;
                    camera.position.y = 2;
                    //alert(l.letterGrid[i][j].xBegin +  " " + l.letterGrid[i][j].zBegin) ;
                    done = true;
                    break;
                }
            }
            if(done) break;
        }

    }

    function getBlake(){
        var rand = Math.random()*(BLAKE001.length-1);
        rand = Math.round(rand);

        return BLAKE001[rand].split(" ");
    }

    function getHuge(){
        var max = 5;
        var cursize = 0;
        var ret = [];
        for(var i=0; i<max; i++){
            var newWord = getBlake();
            for(var j=cursize; j<cursize+newWord.length; j++){
                ret[j] = newWord[j-cursize].toUpperCase();
            }
            cursize += newWord.length;
        }
        return ret;
    }

    //Renders a crossword. xPos and zPos represent the position in the crossword that wordList[0] will have.
    function renderCrossword(wordList, dir, xPos, zPos){
        var cw = new Crossword(wordList, dir, xPos, zPos);

        var grid = cw.getSquareGrid(2);
        return grid;
    }


</script>

</body>
