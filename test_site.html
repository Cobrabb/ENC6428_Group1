<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>


    <body>

        <canvas id ="renderCanvas"></canvas>

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);

        // Lights
        //var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-5, 1, -5), scene);

        // Need a free camera for collisions

        var cameraPos = 30 ;

        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(cameraPos, 1, cameraPos), scene);

        light1.parent = camera;

        //Use this camera position for checking letters --> Easy navigation
        //var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 40, 0), scene);

        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 100, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        ground.material.backFaceCulling = false;
        ground.position = new BABYLON.Vector3(50, 0, 50);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        vidSetup(scene);
        //Simple crate
        renderMap(scene);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = true;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function renderMap(scene){
        
        var stringGrid = [];

        for(var i=0; i<10; i++){
            stringGrid[i] = [];
            for(var j=0; j<10; j++){
                stringGrid[i][j] = "0";
            }
        }

        addWordX(stringGrid, 1, 5, "JOLLY");

        addWordZ(stringGrid, 6, 2, "FOLLY");
        var letterGrid = renderLetterGrid(scene, stringGrid);

    }

    //these functions simulate the crossword for now
    function addWordX(grid, start, zPos, word){
        for(var i=0; i<word.length; i++){
            grid[i+start][zPos] = word[i];
        }
    }

    function addWordZ(grid, start, xPos, word){
        for(var i=word.length-1; i>=0; i--){
            grid[xPos][start-i] = word[i];
        }
    }


</script>

</body>
