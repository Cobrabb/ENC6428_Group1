<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
        <script src="letters.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>


    <body>

        <canvas id ="renderCanvas"></canvas>

<script>


    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);

        // Lights
        var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, 20, 20), scene);

        // Need a free camera for collisions
        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(1, 1, 1), scene);
        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 100, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        ground.material.backFaceCulling = false;
        ground.position = new BABYLON.Vector3(50, 0, 50);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = false;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function renderMap(scene){
		
		//var G = createG(scene, 0, 0, false, true, false, false);

        var C = createC(scene, 0, 0, true, true, true, true);
		
		//var L = createL(scene, 14, 0, false, true, false, true);
		
		//var L = createL(scene, 21, 0, false, false, false, true);
        //alert(L.xBegin + " " + L.xEnd);
        //L.checkCollision(1, 1);
    }

    function checkCollision(playerX, playerZ){
        if(playerX > this.xBegin && playerX < this.xEnd && playerZ > this.zBegin && playerZ < this.zEnd){
            //alert("TEST");
        }
    }


 function createC(scene, x, z, open1, open2, open3, open4) {

        //Outer left wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer right wall
        //createWall(scene, [x + 9, z], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);

        //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        createWall(scene, [x + 6, z], [x + 9, z]);
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 6, z + 9], [x + 9, z + 9]);

        //Inner C
        createWall(scene, [x + 3, z + 3], [x + 9, z + 3]);
        createWall(scene, [x + 3, z + 6], [x + 9, z + 6]);
        //createWall(scene, [x + 6, z + 3], [x + 6, z + 6]);
        createWall(scene, [x + 3, z + 3], [x + 3, z + 6]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z], [x + 9, z + 3]);
        }
        if (!open3) {
            createWall(scene, [x + 3, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }



    function createD(scene, x, z, open1, open2, open3, open4) {

        //Outer right wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer left wall
        createWall(scene, [x + 9, z + 2], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 7]);
    
       //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        createWall(scene, [x + 6, z], [x + 7, z]);
        createWall(scene, [x + 7, z], [x + 9, z + 2]);
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 6, z + 9], [x + 7, z + 9]);
        createWall(scene, [x + 7, z + 9], [x + 9, z + 7]);

        //Inner D
        createWall(scene, [x + 3, z + 3], [x + 5, z + 3]);
        createWall(scene, [x + 3, z + 6], [x + 5, z + 6]);
        createWall(scene, [x + 5, z + 3], [x + 6, z + 4]);
        createWall(scene, [x + 5, z + 6], [x + 6, z + 5]);
        createWall(scene, [x + 6, z + 4], [x + 6, z + 5]);
        createWall(scene, [x + 3, z + 3], [x + 3, z + 6]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z + 3], [x + 9, z + 6]);
        }
        if (!open3) {
            createWall(scene, [x + 3, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }

	 function createG(scene, x, z, open1, open2, open3, open4) {

        //Outer right wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer left wall
        createWall(scene, [x + 9, z + 3], [x + 9, z + 4.5]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);

        //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        createWall(scene, [x + 6, z], [x + 9, z]);
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 6, z + 9], [x + 9, z + 9]); 

        //Inner G
        createWall(scene, [x + 3, z + 3], [x + 6, z + 3]);
        createWall(scene, [x + 3, z + 6], [x + 9, z + 6]);
        //createWall(scene, [x + 6, z + 3], [x + 6, z + 4.5]);
        createWall(scene, [x + 3, z + 3], [x + 3, z + 6]);
        createWall(scene, [x + 9, z + 4.5], [x + 4.5, z + 4.5]);
        createWall(scene, [x + 4.5, z + 4.5], [x + 4.5, z + 3.75]);
        createWall(scene, [x + 4.5, z + 3.75], [x + 6, z + 3.75]);
        createWall(scene, [x + 6, z + 3.75], [x + 6, z + 3]);
        createWall(scene, [x + 6, z + 3], [x + 3, z + 3]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z], [x + 9, z + 3]);
        }
        if (!open3) {
            createWall(scene, [x + 3, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }
	
	
	function createI(scene, x, z, open1, open2, open3, open4){

        //Outer bottom wall
        //createWall(scene, [x, z], [x+3, z]);       
		//Outer right wall
        createWall(scene, [x+3,z], [x+3,z+3]);
		createWall(scene, [x+3,z + 6], [x+3,z+9]);
		//Outer top wall      
		//createWall(scene, [x+3,z+9], [x,z+9]);
		//Outer left wall
        createWall(scene, [x,z], [x,z+3]);
		createWall(scene, [x,z+6], [x,z+9]);  
		
		 if(!open1) {
            createWall(scene, [x,z+9], [x+3,z+9]);
        }
        if(!open2){
            createWall(scene, [x+3,z+3], [x+3,z+6]);
        }
        if(!open3){
            createWall(scene, [x,z], [x+3,z]);        
        }
        if(!open4){
            createWall(scene, [x,z+3], [x,z+6]);
        }

		        
		
        
        
        
       

        return new function(){
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x+3;
            //this always remains the same
            this.zEnd = z+9;
            this.checkCollision = checkCollision;
        };
    }


    //open1 = north
    //open2 = east
    //open3 = south
    //open4 = west
    function createL(scene, x, z, open1, open2, open3, open4){

        //Outer right wall
        createWall(scene, [x,z], [x,z+3]);        
        createWall(scene, [x,z+6], [x,z+9]);        

        createWall(scene, [x+3,z+3], [x+3,z+9]);

        //Outer bottom wall
        createWall(scene, [x+3,z], [x+6,z]);        

        createWall(scene, [x+3,z+3], [x+6,z+3]);        
        
        if(!open1) {
            createWall(scene, [x,z+9], [x+3,z+9]);
        }
        if(!open2){
            createWall(scene, [x+6,z], [x+6,z+3]);
        }
        if(!open3){
            createWall(scene, [x,z], [x+3,z]);        
        }
        if(!open4){
            createWall(scene, [x,z+3], [x,z+6]);
        }

        return new function(){
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x+6;
            //this always remains the same
            this.zEnd = z+9;
            this.checkCollision = checkCollision;
        };
    }


 function createM(scene, x, z, open1, open2, open3, open4) {

        //Outer right wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer left wall
        createWall(scene, [x + 9, z], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);

        //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 9, z + 9], [x + 6, z + 9]);

        //Inner M
        createWall(scene, [x + 3, z], [x + 3, z + 6]);
        createWall(scene, [x + 6, z], [x + 6, z + 6]);
        createWall(scene, [x + 3, z + 6], [x + 4.5, z + 4.5]);
        createWall(scene, [x + 6, z + 6], [x + 4.5, z + 4.5]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z + 3], [x + 9, z + 6]);
        }
        if (!open3) {
            createWall(scene, [x + 9, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }


function createN(scene, x, z, open1, open2, open3, open4) {

        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        createWall(scene, [x + 9, z], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);
        createWall(scene, [x + 6, z + 4], [x + 6, z + 9]);
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 3, z], [x + 3, z + 5]);
        createWall(scene, [x + 6, z], [x + 9, z]);
        createWall(scene, [x + 6, z + 9], [x + 9, z + 9]);
        createWall(scene, [x + 3, z + 5], [x + 6, z]);
        createWall(scene, [x + 3, z + 9], [x + 6, z + 4]);

        if (!open1) {
            createWall(scene, [x + 9, z + 9], [x + 9, z + 6]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z + 3], [x + 9, z + 6]);
        }
        if (!open3) {
            createWall(scene, [x, z], [x + 3, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }



    function createO(scene, x, z, open1, open2, open3, open4) {

        //Outer right wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer left wall
        createWall(scene, [x + 9, z], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);

        //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        createWall(scene, [x + 6, z], [x + 9, z]);
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 6, z + 9], [x + 9, z + 9]);

        //Inner O
        createWall(scene, [x + 3, z + 3], [x + 6, z + 3]);
        createWall(scene, [x + 3, z + 6], [x + 6, z + 6]);
        createWall(scene, [x + 6, z + 3], [x + 6, z + 6]);
        createWall(scene, [x + 3, z + 3], [x + 3, z + 6]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z + 3], [x + 9, z + 6]);
        }
        if (!open3) {
            createWall(scene, [x + 3, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }

    
    
   
   

    function createQ(scene, x, z, open1, open2, open3, open4) {

        //Outer right wall
        createWall(scene, [x, z], [x, z + 3]);
        createWall(scene, [x, z + 6], [x, z + 9]);
        //Outer left wall
        createWall(scene, [x + 9, z], [x + 9, z + 3]);
        createWall(scene, [x + 9, z + 6], [x + 9, z + 9]);

        //Outer bottom wall
        createWall(scene, [x, z], [x + 3, z]);
        createWall(scene, [x + 6, z], [x + 9, z]);
        //Outer top wall
        createWall(scene, [x, z + 9], [x + 3, z + 9]);
        createWall(scene, [x + 6, z + 9], [x + 9, z + 9]);

        //Inner Q
        createWall(scene, [x + 3, z + 3], [x + 4.5, z + 3]);
        createWall(scene, [x + 4.5, z + 3], [x + 4.5, z + 4.5]);
        createWall(scene, [x + 4.5, z + 4.5], [x + 6, z + 4.5]);
        createWall(scene, [x + 3, z + 6], [x + 6, z + 6]);
        createWall(scene, [x + 6, z + 4.5], [x + 6, z + 6]);
        createWall(scene, [x + 3, z + 3], [x + 3, z + 6]);

        if (!open1) {
            createWall(scene, [x + 3, z + 9], [x + 6, z + 9]);
        }
        if (!open2) {
            createWall(scene, [x + 9, z + 3], [x + 9, z + 6]);
        }
        if (!open3) {
            createWall(scene, [x + 3, z], [x + 6, z]);
        }
        if (!open4) {
            createWall(scene, [x, z + 3], [x, z + 6]);
        }

        return new function () {
            this.xBegin = x;
            this.zBegin = z;
            //how far you go in the X direction
            this.xEnd = x + 6;
            //this always remains the same
            this.zEnd = z + 9;
            this.checkCollision = checkCollision;
        };
    }


    function createWall(scene, begin, end){
        var height = 30;
        var scaling = .1;

        var midx = (begin[0]+end[0])/2.0;
        var midz = (begin[1]+end[1])/2.0;

        var box = new BABYLON.Mesh.CreateBox("crate", scaling, scene);
        box.material = new BABYLON.StandardMaterial("Mat", scene);
        box.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
        box.position = new BABYLON.Vector3(midx, (height/2)*scaling, midz);
        box.checkCollisions = true;
        box.scaling.y = height;
        

        var xDist = begin[0]-end[0];
        var zDist = begin[1]-end[1];
        box.scaling.x = (Math.sqrt(xDist*xDist+zDist*zDist))*10;
        box.rotation.y = 0-(Math.atan(zDist/xDist));
    }


</script>

</body>
