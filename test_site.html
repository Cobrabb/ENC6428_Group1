
<!DOCTYPE html>
<html>
    <head>
        <script src="Babylon.js/hand-1.3.8.js"></script>
        <script src="Babylon.js/cannon.js"></script>
        <script src="Babylon.js/Oimo.js"></script>
        <script src="Babylon.js/babylon.2.0.js"></script>
    </head>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>


    <body>

        <canvas id ="renderCanvas"></canvas>

<script>

    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);

        // Lights
        var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(20, 20, 2), scene);
        var light1 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(2, 20, 20), scene);

        // Need a free camera for collisions
        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(-15, 1, -15), scene);
        camera.attachControl(canvas, true);
        camera.speed = 1;
        camera.inertia = .9;
        camera.angularSensibility = 1000; 

        camera.keysUp = [38, 87];
        camera.keysDown = [40, 83]
        camera.keysRight = [39, 68]
        camera.keysLeft = [37, 65]


        // Request pointer lock
        // On click event, request pointer lock
        canvas.addEventListener("click", function(evt) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) {
                canvas.requestPointerLock();
            }
        }, false);

        // Event listener when the pointerlock is updated (or removed by pressing ESC for example).
        var pointerlockchange = function (event) {
            _this.controlEnabled = (
                           document.mozPointerLockElement === canvas
                        || document.webkitPointerLockElement === canvas
                        || document.msPointerLockElement === canvas
                        || document.pointerLockElement === canvas);
            // If the user is alreday locked
            if (!_this.controlEnabled) {
            _this.camera.detachControl(canvas);
            } else {
             _this.camera.attachControl(canvas);
            }
        };

        // Attach events to the document
        document.addEventListener("pointerlockchange", pointerlockchange, false);
        document.addEventListener("mspointerlockchange", pointerlockchange, false);
        document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        document.addEventListener("webkitpointerlockchange", pointerlockchange, false);

        //Ground
        var ground = BABYLON.Mesh.CreatePlane("ground", 20.0, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        ground.material.backFaceCulling = false;
        ground.position = new BABYLON.Vector3(-10, 0, -10);
        ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);

        //Simple crate
        renderMap(scene);

        //Set gravity for the scene (G force like, on Y-axis)
        scene.gravity = new BABYLON.Vector3(0, -0.9, 0);

        // Enable Collisions
        scene.collisionsEnabled = true;

        //Then apply collisions and gravity to the active camera
        camera.checkCollisions = true;
        camera.applyGravity = false;

        //Set the ellipsoid around the camera (e.g. your player's size)
        camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

        //finally, say which mesh will be collisionable
        ground.checkCollisions = true;

        return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function() {
        scene.render();
    });

    window.addEventListener("resize", function(){
        engine.resize();
    });

    function renderMap(scene){

        createL(scene, 0, 0, false, false, true, false);
    }


    //open1 = north
    //open2 = east
    //open3 = south
    //open4 = west
    function createL(scene, x, z, open1, open2, open3, open4){
        //inner
        createWallX(scene, [x-3, z-3], 60);
        createWallZ(scene, [x-3, z-3], 60);

        //outer (part 1)
        createWallZ(scene, [x, z-6], 30);
        createWallZ(scene, [x, z], 30);
        createWallX(scene, [x-6, z], 30);
        createWallX(scene, [x, z], 30);

        if(!open1) {
            createWallX(scene, [x, z-9], 30);
        }
        if(!open2){
            createWallZ(scene, [x-9, z], 30);
        }
        if(!open3){
            createWallX(scene, [x-3, z], 30);
        }
        if(!open4){
            createWallZ(scene, [x, z-3], 30);
        }
    }

    function createWallX(scene, begin, length){
        createBox(scene, .1, begin[0]-(length/2)*.1, .1, begin[1], length, 30, 1);
    }

    function createWallZ(scene, begin, length){
        createBox(scene, .1, begin[0], .1, begin[1]-(length/2)*.1, 1, 30, length);
    }

    function createBox(scene, size, begin1, begin2, begin3, scaling1, scaling2, scaling3){
        var box = new BABYLON.Mesh.CreateBox("crate", size, scene);
        box.material = new BABYLON.StandardMaterial("Mat", scene);
        box.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
        box.position = new BABYLON.Vector3(begin1, begin2+(scaling2*size)/2, begin3);
        box.scaling.x = scaling1;
        box.scaling.y = scaling2;
        box.scaling.z = scaling3;
        box.checkCollisions = true;
    }

</script>

</body>
